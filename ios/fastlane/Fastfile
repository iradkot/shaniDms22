require "base64"
require "fileutils"
require "plist"
require "xcodeproj"

PROJECT_ROOT = File.expand_path("..", __dir__)
XCODEPROJ_PATH = File.join(PROJECT_ROOT, "shaniDms22.xcodeproj")
XCWORKSPACE_PATH = File.join(PROJECT_ROOT, "shaniDms22.xcworkspace")
DEFAULT_TEAM_ID = "8KHU9V3DTQ"

# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#
# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

def builds_directory
  File.expand_path("./builds")
end

def provisioning_profile_path
  File.join(builds_directory, "provisioning.mobileprovision")
end

def decoded_provisioning_profile
  @decoded_provisioning_profile ||= begin
    UI.user_error!("Could not find provisioning profile at #{provisioning_profile_path}") unless File.exist?(provisioning_profile_path)

    profile_xml = sh("security cms -D -i \"#{provisioning_profile_path}\"")
    UI.user_error!("Failed to decode provisioning profile at #{provisioning_profile_path}") if profile_xml.to_s.strip.empty?

    parsed_profile = Plist.parse_xml(profile_xml)
    UI.user_error!("Failed to parse provisioning profile at #{provisioning_profile_path}") if parsed_profile.nil?

    parsed_profile
  end
end

def provisioning_profile_name
  @provisioning_profile_name ||= begin
    name = decoded_provisioning_profile["Name"].to_s.strip
    UI.user_error!("Provisioning profile name missing in #{provisioning_profile_path}") if name.empty?
    name
  end
end

def provisioning_profile_team_id
  @provisioning_profile_team_id ||= begin
    team_ids = decoded_provisioning_profile["TeamIdentifier"]
    Array(team_ids).map { |value| value.to_s.strip }.reject(&:empty?).first
  end
end

def certificate_path
  File.join(builds_directory, "certificate.p12")
end

def decode_secret_to(path:, variable:)
  value = ENV[variable]
  UI.user_error!("Missing environment variable #{variable}") if value.to_s.strip.empty?
  File.binwrite(path, Base64.decode64(value))
  path
end

def ensure_keychain(name:, password:)
  begin
    delete_keychain(name: name)
  rescue StandardError
    UI.message("Keychain #{name} did not exist – continuing")
  end

  create_keychain(
    name: name,
    password: password,
    default_keychain: true,
    unlock: true,
    timeout: 3600,
    lock_when_sleeps: true
  )
end

def configure_signing_for_ci
  FileUtils.mkdir_p(builds_directory)

  keychain_name = ENV.fetch("CI_KEYCHAIN_NAME", "ci-signing")
  keychain_password = ENV.fetch("CI_KEYCHAIN_PASSWORD", "ci-signing")
  runner_temp = ENV["RUNNER_TEMP"] || "/tmp"
  keychain_path = File.join(runner_temp, "#{keychain_name}.keychain-db")

  sh(%(security delete-keychain "#{keychain_path}" || true))
  sh(%(security create-keychain -p "#{keychain_password}" "#{keychain_path}"))
  sh(%(security set-keychain-settings -lut 21600 "#{keychain_path}"))
  sh(%(security unlock-keychain -p "#{keychain_password}" "#{keychain_path}"))
  sh(%(security list-keychains -d user -s "#{keychain_path}"))
  sh(%(security default-keychain -s "#{keychain_path}"))

  decode_secret_to(path: certificate_path, variable: "APPLE_CERTIFICATE_P12")

  sh(%(security import "#{certificate_path}" -k "#{keychain_path}" -P "#{ENV.fetch("APPLE_CERTIFICATE_PASSWORD")}" -A -t cert -f pkcs12))

  sh(%(security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "#{keychain_password}" "#{keychain_path}"))

  UI.message("Keychain debug info after certificate import")
  sh("security list-keychains -d user")
  sh("security show-keychain-info \"#{keychain_path}\" || true")
  sh("security find-identity -p codesigning -v \"#{keychain_path}\" || true")
  sh("security default-keychain || true")
  sh("security find-identity -v -p codesigning || true")

  decode_secret_to(path: provisioning_profile_path, variable: "APPLE_PROVISIONING_PROFILE")

  install_provisioning_profile(path: provisioning_profile_path)
end

def configure_signing_for_local
  FileUtils.mkdir_p(builds_directory)

  get_certificates(
    output_path: builds_directory
  )

  get_provisioning_profile(
    output_path: builds_directory,
    filename: "provisioning.mobileprovision"
  )
end

def appfile_team_id
  env_team_id = ENV.fetch("APPLE_TEAM_ID", ENV["FASTLANE_TEAM_ID"]).to_s.strip
  return env_team_id unless env_team_id.empty?

  team_id = CredentialsManager::AppfileConfig.try_fetch_value(:team_id).to_s.strip
  if team_id.empty?
    appfile_paths = [
      ENV["FASTLANE_APPFILE_PATH"],
      File.expand_path("Appfile", __dir__),
      File.expand_path("../fastlane/Appfile", __dir__)
    ].compact

    appfile_paths.each do |path|
      next unless File.exist?(path)

      match = File.read(path).match(/team_id\(["'](?<team_id>.+?)["']\)/)
      if match && !match[:team_id].to_s.strip.empty?
        team_id = match[:team_id].strip
        break
      end
    end
  end

  team_id = DEFAULT_TEAM_ID if team_id.empty?
  UI.user_error!("No team_id configured in Appfile") if team_id.empty?
  ENV["FASTLANE_TEAM_ID"] ||= team_id
  team_id
end

def resolved_app_identifier
  env_identifier = ENV.fetch("APP_IDENTIFIER", ENV["BUNDLE_IDENTIFIER"]).to_s.strip
  return env_identifier unless env_identifier.empty?

  identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier).to_s.strip
  if identifier.empty?
    appfile_paths = [
      ENV["FASTLANE_APPFILE_PATH"],
      File.expand_path("Appfile", __dir__),
      File.expand_path("../fastlane/Appfile", __dir__)
    ].compact

    appfile_paths.each do |path|
      next unless File.exist?(path)

      match = File.read(path).match(/app_identifier\(["'](?<identifier>.+?)["']\)/)
      if match && !match[:identifier].to_s.strip.empty?
        identifier = match[:identifier].strip
        break
      end
    end
  end

  UI.user_error!("No app_identifier configured in Appfile") if identifier.empty?
  ENV["APP_IDENTIFIER"] ||= identifier
  identifier
end

def provisioning_profile_setup
  UI.message("Using Xcode project at #{XCODEPROJ_PATH}")
  UI.user_error!("Could not find Xcode project at #{XCODEPROJ_PATH}") unless File.exist?(XCODEPROJ_PATH)

  team_id = provisioning_profile_team_id || appfile_team_id

  update_project_provisioning(
    xcodeproj: XCODEPROJ_PATH,
    target_filter: "shaniDms22",
    profile: provisioning_profile_path,
    build_configuration: "Release",
    code_signing_identity: "Apple Distribution"
  )

  ENV["FL_PROJECT_SIGNING_PROJECT_PATH"] = XCODEPROJ_PATH

  update_project_team(
    path: XCODEPROJ_PATH,
    teamid: team_id
  )

  ENV["FASTLANE_TEAM_ID"] = team_id if team_id

  enforce_code_sign_identities(
    project_path: XCODEPROJ_PATH,
    debug_identity: "Apple Development",
    release_identity: "Apple Distribution"
  )

  expected_profile_name = "com.shanidms22 AppStore"
  if provisioning_profile_name && provisioning_profile_name != expected_profile_name
    UI.important("Provisioning profile name (#{provisioning_profile_name}) does not match expected #{expected_profile_name}; export options will use expected name.")
  end

  ENV["FL_EXPECTED_PROFILE_NAME"] = expected_profile_name
end

def enforce_code_sign_identities(project_path:, debug_identity:, release_identity:)
  project = Xcodeproj::Project.open(project_path)
  changed = false

  config_sets = project.targets.map(&:build_configurations) + [project.build_configurations]
  config_sets.flatten.each do |config|
    desired_identity =
      case config.name
      when "Debug"
        debug_identity
      when "Release"
        release_identity
      end

    next unless desired_identity

    changed |= assign_identity(config, desired_identity)
  end

  project.save if changed
end

def assign_identity(configuration, identity)
  settings = configuration.build_settings
  updated = false

  unless settings["CODE_SIGN_IDENTITY"] == identity
    settings["CODE_SIGN_IDENTITY"] = identity
    updated = true
  end

  unless settings["CODE_SIGN_IDENTITY[sdk=iphoneos*]"] == identity
    settings["CODE_SIGN_IDENTITY[sdk=iphoneos*]"] = identity
    updated = true
  end

  updated
end

def app_store_api_key
  key_id = ENV["APP_STORE_CONNECT_KEY_ID"].to_s.strip
  issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"].to_s.strip
  private_key_base64 = ENV["APP_STORE_CONNECT_PRIVATE_KEY"].to_s
  private_key_plain = ENV["APP_STORE_CONNECT_PRIVATE_NOT_ENCODED_TO_64"].to_s

  key_is_base64 = !private_key_base64.strip.empty?
  key_content = if key_is_base64
                  private_key_base64.gsub(/\s+/, "")
                else
                  private_key_plain.strip
                end

  return nil if [key_id, issuer_id, key_content].any? { |value| value.to_s.strip.empty? }

  app_store_connect_api_key(
    key_id: key_id,
    issuer_id: issuer_id,
    key_content: key_content,
    is_key_content_base64: key_is_base64
  )
end

def validate_app_store_connect_credentials!
  key_id = ENV["APP_STORE_CONNECT_KEY_ID"].to_s.strip
  issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"].to_s.strip
  private_key_base64 = ENV["APP_STORE_CONNECT_PRIVATE_KEY"].to_s.strip
  private_key_plain = ENV["APP_STORE_CONNECT_PRIVATE_NOT_ENCODED_TO_64"].to_s.strip

  UI.user_error!("APP_STORE_CONNECT_KEY_ID is required for TestFlight upload") if key_id.empty?
  UI.user_error!("APP_STORE_CONNECT_ISSUER_ID is required for TestFlight upload") if issuer_id.empty?

  unless key_id.match?(/\A[A-Z0-9]{10}\z/i)
    UI.user_error!("APP_STORE_CONNECT_KEY_ID must be the 10-character Key ID from App Store Connect → Users and Access → Keys (example: ABCDE12345).")
  end

  if private_key_base64.empty? && private_key_plain.empty?
    UI.user_error!("Provide either APP_STORE_CONNECT_PRIVATE_KEY (base64) or APP_STORE_CONNECT_PRIVATE_NOT_ENCODED_TO_64 (PEM) for TestFlight upload")
  end

  unless issuer_id.match?(/\A[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\z/i)
    UI.user_error!("APP_STORE_CONNECT_ISSUER_ID must be the Issuer ID UUID (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx) from App Store Connect → Users and Access → Keys. Do not use a Key ID here.")
  end

  unless private_key_base64.empty?
    sanitized_base64 = private_key_base64.gsub(/\s+/, "")

    decoded = begin
      Base64.decode64(sanitized_base64)
    rescue StandardError
      nil
    end

    if decoded.to_s.strip.empty?
      UI.user_error!("APP_STORE_CONNECT_PRIVATE_KEY is not valid base64. Base64-encode the full contents of the downloaded .p8 file and paste it without extra text.")
    end

    unless decoded.include?("BEGIN PRIVATE KEY") || decoded.include?("BEGIN EC PRIVATE KEY")
      UI.user_error!("APP_STORE_CONNECT_PRIVATE_KEY does not decode to a PEM private key. Base64-encode the raw .p8 file contents (including BEGIN/END PRIVATE KEY lines).")
    end
  end

  if !private_key_plain.empty? && private_key_base64.empty?
    unless private_key_plain.include?("BEGIN PRIVATE KEY") || private_key_plain.include?("BEGIN EC PRIVATE KEY")
      UI.user_error!("APP_STORE_CONNECT_PRIVATE_NOT_ENCODED_TO_64 does not look like a PEM private key (missing BEGIN PRIVATE KEY). Paste only the raw PEM contents.")
    end
  end
end

default_platform(:ios)

platform :ios do
  desc "Push a new beta build to TestFlight"
  lane :beta do
    if ENV["CI"]
      configure_signing_for_ci
    else
      configure_signing_for_local
    end

    provisioning_profile_setup

    increment_build_number(xcodeproj: XCODEPROJ_PATH)

    app_identifier = resolved_app_identifier
    profile_name = provisioning_profile_name

    build_app(
      workspace: XCWORKSPACE_PATH,
      scheme: "shaniDms22",
      clean: true,
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          "com.shanidms22" => (ENV["FL_EXPECTED_PROFILE_NAME"] || profile_name || "com.shanidms22 AppStore")
        }
      },
      build_path: "./builds",
      output_directory: "./builds"
    )

    validate_app_store_connect_credentials!
    upload_to_testflight(
      api_key: app_store_api_key
    )
  end

  after_all do
    next unless ENV["CI"]

    keychain_name = ENV.fetch("CI_KEYCHAIN_NAME", "ci-signing")

    begin
      delete_keychain(name: keychain_name)
    rescue StandardError
      UI.message("Keychain #{keychain_name} could not be deleted – skipping")
    end
  end
end
