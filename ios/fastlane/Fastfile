require "base64"
require "fileutils"
require "plist"

PROJECT_ROOT = File.expand_path("..", __dir__)
XCODEPROJ_PATH = File.join(PROJECT_ROOT, "shaniDms22.xcodeproj")
XCWORKSPACE_PATH = File.join(PROJECT_ROOT, "shaniDms22.xcworkspace")
DEFAULT_TEAM_ID = "8KHU9V3DTQ"

# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#
# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

def builds_directory
  File.expand_path("./builds")
end

def provisioning_profile_path
  File.join(builds_directory, "provisioning.mobileprovision")
end

def decoded_provisioning_profile
  @decoded_provisioning_profile ||= begin
    UI.user_error!("Could not find provisioning profile at #{provisioning_profile_path}") unless File.exist?(provisioning_profile_path)

    profile_xml = sh("security cms -D -i \"#{provisioning_profile_path}\"")
    UI.user_error!("Failed to decode provisioning profile at #{provisioning_profile_path}") if profile_xml.to_s.strip.empty?

    parsed_profile = Plist.parse_xml(profile_xml)
    UI.user_error!("Failed to parse provisioning profile at #{provisioning_profile_path}") if parsed_profile.nil?

    parsed_profile
  end
end

def provisioning_profile_name
  @provisioning_profile_name ||= begin
    name = decoded_provisioning_profile["Name"].to_s.strip
    UI.user_error!("Provisioning profile name missing in #{provisioning_profile_path}") if name.empty?
    name
  end
end

def provisioning_profile_team_id
  @provisioning_profile_team_id ||= begin
    team_ids = decoded_provisioning_profile["TeamIdentifier"]
    Array(team_ids).map { |value| value.to_s.strip }.reject(&:empty?).first
  end
end

def certificate_path
  File.join(builds_directory, "certificate.p12")
end

def decode_secret_to(path:, variable:)
  value = ENV[variable]
  UI.user_error!("Missing environment variable #{variable}") if value.to_s.strip.empty?
  File.binwrite(path, Base64.decode64(value))
  path
end

def ensure_keychain(name:, password:)
  begin
    delete_keychain(name: name)
  rescue StandardError
    UI.message("Keychain #{name} did not exist – continuing")
  end

  create_keychain(
    name: name,
    password: password,
    default_keychain: true,
    unlock: true,
    timeout: 3600,
    lock_when_sleeps: true
  )
end

def configure_signing_for_ci
  FileUtils.mkdir_p(builds_directory)

  keychain_name = ENV.fetch("CI_KEYCHAIN_NAME", "ci-signing")
  keychain_password = ENV.fetch("CI_KEYCHAIN_PASSWORD", "ci-signing")

  ensure_keychain(name: keychain_name, password: keychain_password)

  decode_secret_to(path: certificate_path, variable: "APPLE_CERTIFICATE_P12")

  import_certificate(
    certificate_path: certificate_path,
    certificate_password: ENV.fetch("APPLE_CERTIFICATE_PASSWORD"),
    keychain_name: keychain_name,
    keychain_password: keychain_password
  )

  decode_secret_to(path: provisioning_profile_path, variable: "APPLE_PROVISIONING_PROFILE")
end

def configure_signing_for_local
  FileUtils.mkdir_p(builds_directory)

  get_certificates(
    output_path: builds_directory
  )

  get_provisioning_profile(
    output_path: builds_directory,
    filename: "provisioning.mobileprovision"
  )
end

def appfile_team_id
  env_team_id = ENV.fetch("APPLE_TEAM_ID", ENV["FASTLANE_TEAM_ID"]).to_s.strip
  return env_team_id unless env_team_id.empty?

  team_id = CredentialsManager::AppfileConfig.try_fetch_value(:team_id).to_s.strip
  if team_id.empty?
    appfile_paths = [
      ENV["FASTLANE_APPFILE_PATH"],
      File.expand_path("Appfile", __dir__),
      File.expand_path("../fastlane/Appfile", __dir__)
    ].compact

    appfile_paths.each do |path|
      next unless File.exist?(path)

      match = File.read(path).match(/team_id\(["'](?<team_id>.+?)["']\)/)
      if match && !match[:team_id].to_s.strip.empty?
        team_id = match[:team_id].strip
        break
      end
    end
  end

  team_id = DEFAULT_TEAM_ID if team_id.empty?
  UI.user_error!("No team_id configured in Appfile") if team_id.empty?
  ENV["FASTLANE_TEAM_ID"] ||= team_id
  team_id
end

def resolved_app_identifier
  env_identifier = ENV.fetch("APP_IDENTIFIER", ENV["BUNDLE_IDENTIFIER"]).to_s.strip
  return env_identifier unless env_identifier.empty?

  identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier).to_s.strip
  if identifier.empty?
    appfile_paths = [
      ENV["FASTLANE_APPFILE_PATH"],
      File.expand_path("Appfile", __dir__),
      File.expand_path("../fastlane/Appfile", __dir__)
    ].compact

    appfile_paths.each do |path|
      next unless File.exist?(path)

      match = File.read(path).match(/app_identifier\(["'](?<identifier>.+?)["']\)/)
      if match && !match[:identifier].to_s.strip.empty?
        identifier = match[:identifier].strip
        break
      end
    end
  end

  UI.user_error!("No app_identifier configured in Appfile") if identifier.empty?
  ENV["APP_IDENTIFIER"] ||= identifier
  identifier
end

def provisioning_profile_setup
  UI.message("Using Xcode project at #{XCODEPROJ_PATH}")
  UI.user_error!("Could not find Xcode project at #{XCODEPROJ_PATH}") unless File.exist?(XCODEPROJ_PATH)

  team_id = provisioning_profile_team_id || appfile_team_id

  update_project_provisioning(
    xcodeproj: XCODEPROJ_PATH,
    target_filter: "shaniDms22",
    profile: provisioning_profile_path,
    build_configuration: "Release"
  )

  ENV["FL_PROJECT_SIGNING_PROJECT_PATH"] = XCODEPROJ_PATH

  update_project_team(
    path: XCODEPROJ_PATH,
    teamid: team_id
  )

  ENV["FASTLANE_TEAM_ID"] = team_id if team_id
end

def app_store_api_key
  key_id = ENV["APP_STORE_CONNECT_KEY_ID"]
  issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"]
  private_key = ENV["APP_STORE_CONNECT_PRIVATE_KEY"]

  return nil if [key_id, issuer_id, private_key].any? { |value| value.to_s.strip.empty? }

  app_store_connect_api_key(
    key_id: key_id,
    issuer_id: issuer_id,
    key_content: private_key,
    is_key_content_base64: true
  )
end

default_platform(:ios)

platform :ios do
  desc "Push a new beta build to TestFlight"
  lane :beta do
    if ENV["CI"]
      configure_signing_for_ci
    else
      configure_signing_for_local
    end

    provisioning_profile_setup

    increment_build_number(xcodeproj: XCODEPROJ_PATH)

    app_identifier = resolved_app_identifier
    profile_name = provisioning_profile_name

    build_app(
      workspace: XCWORKSPACE_PATH,
      scheme: "shaniDms22",
      clean: true,
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          app_identifier => profile_name
        }
      },
      build_path: "./builds",
      output_directory: "./builds"
    )

    upload_to_testflight(
      api_key: app_store_api_key
    )
  end

  after_all do
    next unless ENV["CI"]

    keychain_name = ENV.fetch("CI_KEYCHAIN_NAME", "ci-signing")

    begin
      delete_keychain(name: keychain_name)
    rescue StandardError
      UI.message("Keychain #{keychain_name} could not be deleted – skipping")
    end
  end
end
